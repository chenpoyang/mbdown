!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ALL_CXX_OBJ	Makefile	/^ALL_CXX_OBJ	=$/;"	m
ALL_CXX_T	Makefile	/^ALL_CXX_T	=$/;"	m
ALL_C_OBJ	Makefile	/^ALL_C_OBJ	= global.o mbdown.o url.o synchro.o bmsg.o$/;"	m
ALL_C_T	Makefile	/^ALL_C_T		= mbdown$/;"	m
ALL_OBJ	Makefile	/^ALL_OBJ		= $(ALL_C_OBJ) $(ALL_CXX_OBJ)$/;"	m
ALL_T	Makefile	/^ALL_T		= $(ALL_C_T) $(ALL_CXX_T)$/;"	m
AR	Makefile	/^AR			= ar rcu$/;"	m
Bmsg	bmsg.h	/^}Bmsg;$/;"	t	typeref:struct:bmsg
CC	Makefile	/^CC			= gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS		= -O2 -Wall -g $(DEFINES)$/;"	m
CXX	Makefile	/^CXX			= g++$/;"	m
CXXFLAGS	Makefile	/^CXXFLAGS	= -O2 -Wall -g $(DEFINES)$/;"	m
DEFINES	Makefile	/^DEFINES		=$/;"	m
ENTRANCE	Makefile	/^ENTRANCE	= none$/;"	m
GLOBAL	global.h	9;"	d
HALEN	global.h	12;"	d
HLEN	url.h	7;"	d
HaUrl	url.h	/^}HaUrl;$/;"	t	typeref:struct:hash_url
INCPATH	Makefile	/^INCPATH		=$/;"	m
LDFLAGS	Makefile	/^LDFLAGS		= $(SYSLDFLAGS) $(MYLDFLAGS)$/;"	m
LIBS	Makefile	/^LIBS		= $(SYSLIBS) $(MYLIBS)$/;"	m
LLEN	url.h	9;"	d
LOAPATH	Makefile	/^LOAPATH		=$/;"	m
MAXLINE	global.h	24;"	d
MAX_URL_ID	url.h	13;"	d
MYCFLAGS	Makefile	/^MYCFLAGS	=$/;"	m
MYLDFLAGS	Makefile	/^MYLDFLAGS	=$/;"	m
MYLIBS	Makefile	/^MYLIBS		=$/;"	m
M_HIDE	global.h	20;"	d
M_LOCK	synchro.h	9;"	d
M_SHOW	global.h	21;"	d
M_UNLOCK	synchro.h	13;"	d
RANLIB	Makefile	/^RANLIB		= ranlib$/;"	m
RM	Makefile	/^RM			= rm -f$/;"	m
RootBmsg	bmsg.h	/^}RootBmsg;$/;"	t	typeref:struct:root_bmsg
RootUrl	url.h	/^}Url, RootUrl;$/;"	t	typeref:struct:url
SLEN	url.h	11;"	d
SYSCFLAGS	Makefile	/^SYSCFLAGS	=$/;"	m
SYSLDFLAGS	Makefile	/^SYSLDFLAGS	=$/;"	m
SYSLIBS	Makefile	/^SYSLIBS		= -lpthread$/;"	m
ULEN	url.h	5;"	d
UNIT	bmsg.h	5;"	d
Url	url.h	/^}Url, RootUrl;$/;"	t	typeref:struct:url
_BMSG_H_	bmsg.h	2;"	d
_GLOBAL_H_	global.h	2;"	d
_SYNCHRO_H_	synchro.h	2;"	d
_URL_H_	url.h	2;"	d
add_bmsg	bmsg.c	/^void add_bmsg(RootBmsg *root_bmsg, Bmsg *bmsg)$/;"	f	signature:(RootBmsg *root_bmsg, Bmsg *bmsg)
add_bmsg	bmsg.h	/^void add_bmsg(RootBmsg *root_bmsg, Bmsg *bmsg);$/;"	p	signature:(RootBmsg *root_bmsg, Bmsg *bmsg)
add_bmsg_header	bmsg.c	/^void add_bmsg_header(Bmsg *header, Bmsg *bmsg)$/;"	f	signature:(Bmsg *header, Bmsg *bmsg)
add_bmsg_header	bmsg.h	/^void add_bmsg_header(Bmsg *header, Bmsg *bmsg);$/;"	p	signature:(Bmsg *header, Bmsg *bmsg)
add_new_url	url.c	/^void add_new_url(RootUrl *root_url, const char *url)$/;"	f	signature:(RootUrl *root_url, const char *url)
add_new_url	url.h	/^void add_new_url(RootUrl *root_url, const char *url);$/;"	p	signature:(RootUrl *root_url, const char *url)
add_url_header	bmsg.c	/^void add_url_header(RootBmsg *root_bmsg, const Bmsg *header)$/;"	f	signature:(RootBmsg *root_bmsg, const Bmsg *header)
add_url_header	bmsg.h	/^void add_url_header(RootBmsg *root_bmsg, const Bmsg *header);$/;"	p	signature:(RootBmsg *root_bmsg, const Bmsg *header)
begin	bmsg.h	/^	unsigned short begin;$/;"	m	struct:bmsg	access:public
bmsg	bmsg.h	/^typedef struct bmsg {$/;"	s
bmsg::begin	bmsg.h	/^	unsigned short begin;$/;"	m	struct:bmsg	access:public
bmsg::end	bmsg.h	/^	unsigned short end;$/;"	m	struct:bmsg	access:public
bmsg::next	bmsg.h	/^	struct bmsg *next;		\/* single linked list *\/$/;"	m	struct:bmsg	typeref:struct:bmsg::bmsg	access:public
bmsg::next_hdr	bmsg.h	/^	struct bmsg *next_hdr;	\/* netx url bmsgs *\/$/;"	m	struct:bmsg	typeref:struct:bmsg::bmsg	access:public
bmsg::to_bps	bmsg.h	/^	int to_bps;		\/* the numbsers of breakpoints *\/$/;"	m	struct:bmsg	access:public
bmsg::to_bytes	bmsg.h	/^	int to_bytes;$/;"	m	struct:bmsg	access:public
bmsg::url_id	bmsg.h	/^	int url_id;$/;"	m	struct:bmsg	access:public
bzero	global.h	14;"	d
count_url_id	url.c	/^static unsigned int count_url_id = 0;	\/* for generating unique url id *\/$/;"	v	file:
download	mbdown.c	/^void download(const char *url)$/;"	f	signature:(const char *url)
download	mbdown.c	/^void download(const char *url);$/;"	p	file:	signature:(const char *url)
end	bmsg.h	/^	unsigned short end;$/;"	m	struct:bmsg	access:public
find_url	url.c	/^Url * find_url(HaUrl *url_htable, const int len, const int url_id)$/;"	f	signature:(HaUrl *url_htable, const int len, const int url_id)
find_url	url.h	/^Url * find_url(HaUrl *url_htable, const int len, const int url_id);$/;"	p	signature:(HaUrl *url_htable, const int len, const int url_id)
find_url_header	bmsg.c	/^Bmsg * find_url_header(const RootBmsg *root_bmsg, const int url_id)$/;"	f	signature:(const RootBmsg *root_bmsg, const int url_id)
find_url_header	bmsg.h	/^Bmsg * find_url_header(const RootBmsg *root_bmsg, const int url_id);$/;"	p	signature:(const RootBmsg *root_bmsg, const int url_id)
get_host_name	url.c	/^void get_host_name(const char *url, char *hostname)$/;"	f	signature:(const char *url, char *hostname)
get_host_name	url.h	/^void get_host_name(const char *url, char *hostname);$/;"	p	signature:(const char *url, char *hostname)
get_port	url.c	/^int get_port(const char *url)$/;"	f	signature:(const char *url)
get_port	url.h	/^int get_port(const char *url);$/;"	p	signature:(const char *url)
get_resource	url.c	/^void get_resource(const char *url, char *resource)$/;"	f	signature:(const char *url, char *resource)
get_resource	url.h	/^void get_resource(const char *url, char *resource);$/;"	p	signature:(const char *url, char *resource)
get_scheme	url.c	/^void get_scheme(const char *url, char *scheme)$/;"	f	signature:(const char *url, char *scheme)
get_scheme	url.h	/^void get_scheme(const char *url, char *scheme);$/;"	p	signature:(const char *url, char *scheme)
get_url_id	url.c	/^unsigned int get_url_id()$/;"	f
get_url_id	url.h	/^unsigned int get_url_id();$/;"	p	signature:()
hash_url	url.c	/^void hash_url(HaUrl *url_htable, Url *url)$/;"	f	signature:(HaUrl *url_htable, Url *url)
hash_url	url.h	/^typedef struct hash_url {$/;"	s
hash_url	url.h	/^void hash_url(HaUrl *url_htable, Url *url);$/;"	p	signature:(HaUrl *url_htable, Url *url)
hash_url::next	url.h	/^	struct hash_url *next;$/;"	m	struct:hash_url	typeref:struct:hash_url::hash_url	access:public
hash_url::url	url.h	/^	struct url *url;$/;"	m	struct:hash_url	typeref:struct:hash_url::url	access:public
head	bmsg.h	/^	struct bmsg *head;$/;"	m	struct:root_bmsg	typeref:struct:root_bmsg::bmsg	access:public
host	url.h	/^	char host[HLEN];	\/* remote host, eg: www.innlab.net *\/$/;"	m	struct:url	access:public
id	url.h	/^	unsigned int id;				\/* unique id for quickly find *\/$/;"	m	struct:url	access:public
init_all	url.c	/^void init_all()$/;"	f
init_all	url.h	/^void init_all();$/;"	p	signature:()
init_hash_table	url.c	/^void init_hash_table(HaUrl *url_htable, const int len)$/;"	f	signature:(HaUrl *url_htable, const int len)
init_hash_table	url.h	/^void init_hash_table(HaUrl *url_htable, const int len);$/;"	p	signature:(HaUrl *url_htable, const int len)
init_root_bmsg	bmsg.c	/^void init_root_bmsg(RootBmsg *root_bmsg)$/;"	f	signature:(RootBmsg *root_bmsg)
init_root_bmsg	bmsg.h	/^void init_root_bmsg(RootBmsg *root_bmsg);$/;"	p	signature:(RootBmsg *root_bmsg)
init_root_url	url.c	/^void init_root_url(RootUrl *root_url)$/;"	f	signature:(RootUrl *root_url)
init_root_url	url.h	/^void init_root_url(RootUrl *root_url);$/;"	p	signature:(RootUrl *root_url)
m_error	global.h	8;"	d
m_protect	synchro.h	/^pthread_mutex_t m_protect;$/;"	v
m_tolower	global.c	/^void m_tolower(char *str)$/;"	f	signature:(char *str)
m_tolower	global.h	/^void m_tolower(char *str);$/;"	p	signature:(char *str)
main	mbdown.c	/^int main(int argc, char *argv[])$/;"	f	signature:(int argc, char *argv[])
merr_deal	global.c	/^void merr_deal(const int flg, const char *fmt, va_list ap)$/;"	f	signature:(const int flg, const char *fmt, va_list ap)
merr_deal	global.h	/^void merr_deal(const int flg, const char *fmt, va_list ap);$/;"	p	signature:(const int flg, const char *fmt, va_list ap)
merr_dump	global.c	/^void merr_dump(const char *fmt, ...)$/;"	f	signature:(const char *fmt, ...)
merr_dump	global.h	/^void merr_dump(const char *fmt, ...);$/;"	p	signature:(const char *fmt, ...)
merr_msg	global.c	/^void merr_msg(const char *fmt, ...)$/;"	f	signature:(const char *fmt, ...)
merr_msg	global.h	/^void merr_msg(const char *fmt, ...);$/;"	p	signature:(const char *fmt, ...)
merr_quit	global.c	/^void merr_quit(const char *fmt, ...)$/;"	f	signature:(const char *fmt, ...)
merr_quit	global.h	/^void merr_quit(const char *fmt, ...);$/;"	p	signature:(const char *fmt, ...)
merr_sys	global.c	/^void merr_sys(const char *fmt, ...)$/;"	f	signature:(const char *fmt, ...)
merr_sys	global.h	/^void merr_sys(const char *fmt, ...);$/;"	p	signature:(const char *fmt, ...)
new_url_node	url.c	/^Url * new_url_node(const char *url)$/;"	f	signature:(const char *url)
new_url_node	url.h	/^Url * new_url_node(const char *url);$/;"	p	signature:(const char *url)
next	bmsg.h	/^	struct bmsg *next;		\/* single linked list *\/$/;"	m	struct:bmsg	typeref:struct:bmsg::bmsg	access:public
next	url.h	/^	struct hash_url *next;$/;"	m	struct:hash_url	typeref:struct:hash_url::hash_url	access:public
next	url.h	/^	struct url *next;	\/* single linked list *\/$/;"	m	struct:url	typeref:struct:url::url	access:public
next_hdr	bmsg.h	/^	struct bmsg *next_hdr;	\/* netx url bmsgs *\/$/;"	m	struct:bmsg	typeref:struct:bmsg::bmsg	access:public
port	url.h	/^	int port;$/;"	m	struct:url	access:public
release_all	url.c	/^void release_all(RootUrl *root_url)$/;"	f	signature:(RootUrl *root_url)
release_all	url.h	/^void release_all(RootUrl *root_url);$/;"	p	signature:(RootUrl *root_url)
remove_url	url.c	/^void remove_url(RootUrl *root_url, const Url *url)$/;"	f	signature:(RootUrl *root_url, const Url *url)
remove_url	url.h	/^void remove_url(RootUrl *root_url, const Url *url);$/;"	p	signature:(RootUrl *root_url, const Url *url)
res	url.h	/^	char res[LLEN];		\/* the location of resource below the host *\/$/;"	m	struct:url	access:public
root_bmsg	bmsg.c	/^RootBmsg *root_bmsg = NULL;$/;"	v
root_bmsg	bmsg.h	/^typedef struct root_bmsg {$/;"	s
root_bmsg::head	bmsg.h	/^	struct bmsg *head;$/;"	m	struct:root_bmsg	typeref:struct:root_bmsg::bmsg	access:public
root_bmsg::tail	bmsg.h	/^	struct bmsg *tail;$/;"	m	struct:root_bmsg	typeref:struct:root_bmsg::bmsg	access:public
root_url	url.c	/^RootUrl *root_url = NULL;	\/* root url manager *\/$/;"	v
scheme	url.h	/^	char scheme[SLEN];	\/* protocal, eg: http *\/$/;"	m	struct:url	access:public
tail	bmsg.h	/^	struct bmsg *tail;$/;"	m	struct:root_bmsg	typeref:struct:root_bmsg::bmsg	access:public
thread_wait	synchro.c	/^void thread_wait(const int sec)$/;"	f	signature:(const int sec)
thread_wait	synchro.h	/^void thread_wait(const int sec);$/;"	p	signature:(const int sec)
to_bps	bmsg.h	/^	int to_bps;		\/* the numbsers of breakpoints *\/$/;"	m	struct:bmsg	access:public
to_bytes	bmsg.h	/^	int to_bytes;$/;"	m	struct:bmsg	access:public
u_int	global.h	16;"	d
unhash_url	url.c	/^void unhash_url(HaUrl *url_htable, Url *url)$/;"	f	signature:(HaUrl *url_htable, Url *url)
unhash_url	url.h	/^void unhash_url(HaUrl *url_htable, Url *url);$/;"	p	signature:(HaUrl *url_htable, Url *url)
url	url.h	/^	char url[ULEN];		\/* complete url *\/$/;"	m	struct:url	access:public
url	url.h	/^	struct url *url;$/;"	m	struct:hash_url	typeref:struct:hash_url::url	access:public
url	url.h	/^typedef struct url {$/;"	s
url::host	url.h	/^	char host[HLEN];	\/* remote host, eg: www.innlab.net *\/$/;"	m	struct:url	access:public
url::id	url.h	/^	unsigned int id;				\/* unique id for quickly find *\/$/;"	m	struct:url	access:public
url::next	url.h	/^	struct url *next;	\/* single linked list *\/$/;"	m	struct:url	typeref:struct:url::url	access:public
url::port	url.h	/^	int port;$/;"	m	struct:url	access:public
url::res	url.h	/^	char res[LLEN];		\/* the location of resource below the host *\/$/;"	m	struct:url	access:public
url::scheme	url.h	/^	char scheme[SLEN];	\/* protocal, eg: http *\/$/;"	m	struct:url	access:public
url::url	url.h	/^	char url[ULEN];		\/* complete url *\/$/;"	m	struct:url	access:public
url_htable	url.c	/^HaUrl url_htable[HALEN];$/;"	v
url_id	bmsg.h	/^	int url_id;$/;"	m	struct:bmsg	access:public
