!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ALL_OBJ	Makefile	/^ALL_OBJ	= global.o mbdown.o url.o synchro.o bmsg.o http.o$/;"	m
ALL_T	Makefile	/^ALL_T		= mbdown$/;"	m
Bmsg	bmsg.h	/^}Bmsg;$/;"	t	typeref:struct:bmsg
CC	Makefile	/^CC			= gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS		= -O2 -Wall -g $(DEFINES)$/;"	m
CONNECT	http.h	/^	CONNECT$/;"	e	enum:method
CXXFLAGS	Makefile	/^CXXFLAGS	= -O2 -Wall -g $(DEFINES)$/;"	m
DELETE	http.h	/^	DELETE, $/;"	e	enum:method
GET	http.h	/^	GET, $/;"	e	enum:method
GLOBAL	global.h	10;"	d
HALEN	global.h	12;"	d
HEAD	http.h	/^	HEAD, $/;"	e	enum:method
HLEN	url.h	7;"	d
HTTP0_9	http.h	/^	HTTP0_9,$/;"	e	enum:httpv
HTTP1_0	http.h	/^	HTTP1_0,$/;"	e	enum:httpv
HTTP1_1	http.h	/^	HTTP1_1$/;"	e	enum:httpv
H_LEN	http.h	6;"	d
HaUrl	url.h	/^}HaUrl;$/;"	t	typeref:struct:hash_url
LLEN	url.h	9;"	d
MAXLINE	global.h	23;"	d
MAX_ETH_MTU	global.h	14;"	d
MAX_LEN	http.h	4;"	d
MAX_URL_ID	url.h	13;"	d
M_HIDE	global.h	17;"	d
M_LOCK	synchro.h	9;"	d
M_SHOW	global.h	18;"	d
M_UNLOCK	synchro.h	13;"	d
OPTIONS	http.h	/^	OPTIONS, $/;"	e	enum:method
POST	http.h	/^	POST, $/;"	e	enum:method
PUT	http.h	/^	PUT, $/;"	e	enum:method
R_LEN	http.h	5;"	d
Req	http.h	/^}Req;$/;"	v	typeref:struct:req
Resp	http.h	/^}Resp;$/;"	v	typeref:struct:resp
RootBmsg	bmsg.h	/^}RootBmsg;$/;"	t	typeref:struct:root_bmsg
RootUrl	url.h	/^}Url, RootUrl;$/;"	t	typeref:struct:url
SLEN	url.h	11;"	d
TRACE	http.h	/^	TRACE, $/;"	e	enum:method
ULEN	url.h	5;"	d
UNIT	bmsg.h	5;"	d
Url	url.h	/^}Url, RootUrl;$/;"	t	typeref:struct:url
_BMSG_H_	bmsg.h	2;"	d
_GLOBAL_H_	global.h	2;"	d
_HTTP_H_	http.h	2;"	d
_SYNCHRO_H_	synchro.h	2;"	d
_URL_H_	url.h	2;"	d
add_bmsg	bmsg.c	/^void add_bmsg(RootBmsg *root_bmsg, Bmsg *bmsg)$/;"	f	signature:(RootBmsg *root_bmsg, Bmsg *bmsg)
add_bmsg	bmsg.h	/^void add_bmsg(RootBmsg *root_bmsg, Bmsg *bmsg);$/;"	p	signature:(RootBmsg *root_bmsg, Bmsg *bmsg)
add_bmsg_header	bmsg.c	/^void add_bmsg_header(Bmsg *header, Bmsg *bmsg)$/;"	f	signature:(Bmsg *header, Bmsg *bmsg)
add_bmsg_header	bmsg.h	/^void add_bmsg_header(Bmsg *header, Bmsg *bmsg);$/;"	p	signature:(Bmsg *header, Bmsg *bmsg)
add_new_url	url.c	/^void add_new_url(RootUrl *root_url, const char *url)$/;"	f	signature:(RootUrl *root_url, const char *url)
add_new_url	url.h	/^void add_new_url(RootUrl *root_url, const char *url);$/;"	p	signature:(RootUrl *root_url, const char *url)
add_url_header	bmsg.c	/^void add_url_header(RootBmsg *root_bmsg, const Bmsg *header)$/;"	f	signature:(RootBmsg *root_bmsg, const Bmsg *header)
add_url_header	bmsg.h	/^void add_url_header(RootBmsg *root_bmsg, const Bmsg *header);$/;"	p	signature:(RootBmsg *root_bmsg, const Bmsg *header)
begin	bmsg.h	/^	unsigned short begin;$/;"	m	struct:bmsg	access:public
bmsg	bmsg.h	/^typedef struct bmsg {$/;"	s
bmsg::begin	bmsg.h	/^	unsigned short begin;$/;"	m	struct:bmsg	access:public
bmsg::end	bmsg.h	/^	unsigned short end;$/;"	m	struct:bmsg	access:public
bmsg::next	bmsg.h	/^	struct bmsg *next;		\/* single linked list *\/$/;"	m	struct:bmsg	typeref:struct:bmsg::bmsg	access:public
bmsg::next_hdr	bmsg.h	/^	struct bmsg *next_hdr;	\/* netx url bmsgs *\/$/;"	m	struct:bmsg	typeref:struct:bmsg::bmsg	access:public
bmsg::to_bps	bmsg.h	/^	int to_bps;		\/* the numbsers of breakpoints *\/$/;"	m	struct:bmsg	access:public
bmsg::to_bytes	bmsg.h	/^	int to_bytes;$/;"	m	struct:bmsg	access:public
bmsg::url_id	bmsg.h	/^	int url_id;$/;"	m	struct:bmsg	access:public
bzero	global.h	15;"	d
count_url_id	url.c	/^static unsigned int count_url_id = 0;	\/* for generating unique url id *\/$/;"	v	file:
download	mbdown.c	/^void download(const char *url)$/;"	f	signature:(const char *url)
download	mbdown.c	/^void download(const char *url);$/;"	p	file:	signature:(const char *url)
end	bmsg.h	/^	unsigned short end;$/;"	m	struct:bmsg	access:public
escape_spec	url.c	/^void escape_spec(const char *res, char *buf)$/;"	f	signature:(const char *res, char *buf)
escape_spec	url.h	/^void escape_spec(const char *res, char *ret_str);$/;"	p	signature:(const char *res, char *ret_str)
find_url	url.c	/^Url * find_url(HaUrl *url_htable, const int len, const int url_id)$/;"	f	signature:(HaUrl *url_htable, const int len, const int url_id)
find_url	url.h	/^Url * find_url(HaUrl *url_htable, const int len, const int url_id);$/;"	p	signature:(HaUrl *url_htable, const int len, const int url_id)
find_url_header	bmsg.c	/^Bmsg * find_url_header(const RootBmsg *root_bmsg, const int url_id)$/;"	f	signature:(const RootBmsg *root_bmsg, const int url_id)
find_url_header	bmsg.h	/^Bmsg * find_url_header(const RootBmsg *root_bmsg, const int url_id);$/;"	p	signature:(const RootBmsg *root_bmsg, const int url_id)
get_host_name	url.c	/^void get_host_name(const char *url, char *hostname)$/;"	f	signature:(const char *url, char *hostname)
get_host_name	url.h	/^void get_host_name(const char *url, char *hostname);$/;"	p	signature:(const char *url, char *hostname)
get_port	url.c	/^int get_port(const char *url)$/;"	f	signature:(const char *url)
get_port	url.h	/^int get_port(const char *url);$/;"	p	signature:(const char *url)
get_resource	url.c	/^void get_resource(const char *url, char *resource)$/;"	f	signature:(const char *url, char *resource)
get_resource	url.h	/^void get_resource(const char *url, char *resource);$/;"	p	signature:(const char *url, char *resource)
get_scheme	url.c	/^void get_scheme(const char *url, char *scheme)$/;"	f	signature:(const char *url, char *scheme)
get_scheme	url.h	/^void get_scheme(const char *url, char *scheme);$/;"	p	signature:(const char *url, char *scheme)
get_url_id	url.c	/^unsigned int get_url_id()$/;"	f
get_url_id	url.h	/^unsigned int get_url_id();$/;"	p	signature:()
hash_url	url.c	/^void hash_url(HaUrl *url_htable, Url *url)$/;"	f	signature:(HaUrl *url_htable, Url *url)
hash_url	url.h	/^typedef struct hash_url {$/;"	s
hash_url	url.h	/^void hash_url(HaUrl *url_htable, Url *url);$/;"	p	signature:(HaUrl *url_htable, Url *url)
hash_url::next	url.h	/^	struct hash_url *next;$/;"	m	struct:hash_url	typeref:struct:hash_url::hash_url	access:public
hash_url::url	url.h	/^	struct url *url;$/;"	m	struct:hash_url	typeref:struct:hash_url::url	access:public
head	bmsg.h	/^	struct bmsg *head;$/;"	m	struct:root_bmsg	typeref:struct:root_bmsg::bmsg	access:public
host	http.h	/^	char host[H_LEN];	\/* 主机 *\/$/;"	m	struct:req	access:public
host	url.h	/^	char host[HLEN];	\/* remote host, eg: www.innlab.net *\/$/;"	m	struct:url	access:public
httpv	http.h	/^enum httpv {$/;"	g
id	url.h	/^	unsigned int id;				\/* unique id for quickly find *\/$/;"	m	struct:url	access:public
init_all	url.c	/^void init_all()$/;"	f
init_all	url.h	/^void init_all();$/;"	p	signature:()
init_hash_table	url.c	/^void init_hash_table(HaUrl *url_htable, const int len)$/;"	f	signature:(HaUrl *url_htable, const int len)
init_hash_table	url.h	/^void init_hash_table(HaUrl *url_htable, const int len);$/;"	p	signature:(HaUrl *url_htable, const int len)
init_root_bmsg	bmsg.c	/^void init_root_bmsg(RootBmsg *root_bmsg)$/;"	f	signature:(RootBmsg *root_bmsg)
init_root_bmsg	bmsg.h	/^void init_root_bmsg(RootBmsg *root_bmsg);$/;"	p	signature:(RootBmsg *root_bmsg)
init_root_url	url.c	/^void init_root_url(RootUrl *root_url)$/;"	f	signature:(RootUrl *root_url)
init_root_url	url.h	/^void init_root_url(RootUrl *root_url);$/;"	p	signature:(RootUrl *root_url)
init_url_msg	url.c	/^void init_url_msg(Url *url, const char *url_str)$/;"	f	signature:(Url *url, const char *url_str)
init_url_msg	url.h	/^void init_url_msg(Url *url);$/;"	p	signature:(Url *url)
m_error	global.h	8;"	d
m_protect	synchro.h	/^pthread_mutex_t m_protect;$/;"	v
m_tolower	global.c	/^void m_tolower(char *str)$/;"	f	signature:(char *str)
m_tolower	global.h	/^void m_tolower(char *str);$/;"	p	signature:(char *str)
main	mbdown.c	/^int main(int argc, char *argv[])$/;"	f	signature:(int argc, char *argv[])
merr_deal	global.c	/^void merr_deal(const int flg, const char *fmt, va_list ap)$/;"	f	signature:(const int flg, const char *fmt, va_list ap)
merr_deal	global.h	/^void merr_deal(const int flg, const char *fmt, va_list ap);$/;"	p	signature:(const int flg, const char *fmt, va_list ap)
merr_dump	global.c	/^void merr_dump(const char *fmt, ...)$/;"	f	signature:(const char *fmt, ...)
merr_dump	global.h	/^void merr_dump(const char *fmt, ...);$/;"	p	signature:(const char *fmt, ...)
merr_msg	global.c	/^void merr_msg(const char *fmt, ...)$/;"	f	signature:(const char *fmt, ...)
merr_msg	global.h	/^void merr_msg(const char *fmt, ...);$/;"	p	signature:(const char *fmt, ...)
merr_quit	global.c	/^void merr_quit(const char *fmt, ...)$/;"	f	signature:(const char *fmt, ...)
merr_quit	global.h	/^void merr_quit(const char *fmt, ...);$/;"	p	signature:(const char *fmt, ...)
merr_sys	global.c	/^void merr_sys(const char *fmt, ...)$/;"	f	signature:(const char *fmt, ...)
merr_sys	global.h	/^void merr_sys(const char *fmt, ...);$/;"	p	signature:(const char *fmt, ...)
method	http.h	/^enum method {$/;"	g
mthd	http.h	/^	enum method mthd;	\/* 请求方式 *\/$/;"	m	struct:req	typeref:enum:req::method	access:public
new_url_node	url.c	/^Url * new_url_node(const char *url)$/;"	f	signature:(const char *url)
new_url_node	url.h	/^Url * new_url_node(const char *url);$/;"	p	signature:(const char *url)
next	bmsg.h	/^	struct bmsg *next;		\/* single linked list *\/$/;"	m	struct:bmsg	typeref:struct:bmsg::bmsg	access:public
next	url.h	/^	struct hash_url *next;$/;"	m	struct:hash_url	typeref:struct:hash_url::hash_url	access:public
next	url.h	/^	struct url *next;	\/* single linked list *\/$/;"	m	struct:url	typeref:struct:url::url	access:public
next_hdr	bmsg.h	/^	struct bmsg *next_hdr;	\/* netx url bmsgs *\/$/;"	m	struct:bmsg	typeref:struct:bmsg::bmsg	access:public
port	http.h	/^    unsigned int port;$/;"	m	struct:req	access:public
port	url.h	/^	int port;$/;"	m	struct:url	access:public
release_all	url.c	/^void release_all(RootUrl *root_url)$/;"	f	signature:(RootUrl *root_url)
release_all	url.h	/^void release_all(RootUrl *root_url);$/;"	p	signature:(RootUrl *root_url)
remove_url	url.c	/^void remove_url(RootUrl *root_url, const Url *url)$/;"	f	signature:(RootUrl *root_url, const Url *url)
remove_url	url.h	/^void remove_url(RootUrl *root_url, const Url *url);$/;"	p	signature:(RootUrl *root_url, const Url *url)
req	http.h	/^struct req {$/;"	s
req::host	http.h	/^	char host[H_LEN];	\/* 主机 *\/$/;"	m	struct:req	access:public
req::mthd	http.h	/^	enum method mthd;	\/* 请求方式 *\/$/;"	m	struct:req	typeref:enum:req::method	access:public
req::port	http.h	/^    unsigned int port;$/;"	m	struct:req	access:public
req::res	http.h	/^	char res[R_LEN];	\/* 资源位置 *\/$/;"	m	struct:req	access:public
req::str	http.h	/^	char str[MAX_LEN];	\/* 封装的请求头 *\/$/;"	m	struct:req	access:public
res	http.h	/^	char res[R_LEN];	\/* 资源位置 *\/$/;"	m	struct:req	access:public
res	url.h	/^	char res[LLEN];		\/* the location of resource below the host *\/$/;"	m	struct:url	access:public
resp	http.h	/^struct resp {$/;"	s
resp::str	http.h	/^	char str[MAX_LEN];$/;"	m	struct:resp	access:public
root_bmsg	bmsg.c	/^RootBmsg *root_bmsg = NULL;$/;"	v
root_bmsg	bmsg.h	/^typedef struct root_bmsg {$/;"	s
root_bmsg::head	bmsg.h	/^	struct bmsg *head;$/;"	m	struct:root_bmsg	typeref:struct:root_bmsg::bmsg	access:public
root_bmsg::tail	bmsg.h	/^	struct bmsg *tail;$/;"	m	struct:root_bmsg	typeref:struct:root_bmsg::bmsg	access:public
root_url	url.c	/^RootUrl *root_url = NULL;	\/* root url manager *\/$/;"	v
scheme	url.h	/^	char scheme[SLEN];	\/* protocal, eg: http *\/$/;"	m	struct:url	access:public
str	http.h	/^	char str[MAX_LEN];	\/* 封装的请求头 *\/$/;"	m	struct:req	access:public
str	http.h	/^	char str[MAX_LEN];$/;"	m	struct:resp	access:public
tail	bmsg.h	/^	struct bmsg *tail;$/;"	m	struct:root_bmsg	typeref:struct:root_bmsg::bmsg	access:public
thread_wait	synchro.c	/^void thread_wait(const int sec)$/;"	f	signature:(const int sec)
thread_wait	synchro.h	/^void thread_wait(const int sec);$/;"	p	signature:(const int sec)
to_bps	bmsg.h	/^	int to_bps;		\/* the numbsers of breakpoints *\/$/;"	m	struct:bmsg	access:public
to_bytes	bmsg.h	/^	int to_bytes;$/;"	m	struct:bmsg	access:public
u_int	global.h	16;"	d
unhash_url	url.c	/^void unhash_url(HaUrl *url_htable, Url *url)$/;"	f	signature:(HaUrl *url_htable, Url *url)
unhash_url	url.h	/^void unhash_url(HaUrl *url_htable, Url *url);$/;"	p	signature:(HaUrl *url_htable, Url *url)
url	url.h	/^	char url[ULEN];		\/* complete url *\/$/;"	m	struct:url	access:public
url	url.h	/^	struct url *url;$/;"	m	struct:hash_url	typeref:struct:hash_url::url	access:public
url	url.h	/^typedef struct url {$/;"	s
url::host	url.h	/^	char host[HLEN];	\/* remote host, eg: www.innlab.net *\/$/;"	m	struct:url	access:public
url::id	url.h	/^	unsigned int id;				\/* unique id for quickly find *\/$/;"	m	struct:url	access:public
url::next	url.h	/^	struct url *next;	\/* single linked list *\/$/;"	m	struct:url	typeref:struct:url::url	access:public
url::port	url.h	/^	int port;$/;"	m	struct:url	access:public
url::res	url.h	/^	char res[LLEN];		\/* the location of resource below the host *\/$/;"	m	struct:url	access:public
url::scheme	url.h	/^	char scheme[SLEN];	\/* protocal, eg: http *\/$/;"	m	struct:url	access:public
url::url	url.h	/^	char url[ULEN];		\/* complete url *\/$/;"	m	struct:url	access:public
url_htable	url.c	/^HaUrl url_htable[HALEN];$/;"	v
url_id	bmsg.h	/^	int url_id;$/;"	m	struct:bmsg	access:public
